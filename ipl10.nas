; kusa-os
; TAB=4

CYLS	EQU		10				; 定数宣言。CYLS=10という意味。Cylindersの略でCYLSとした模様

		ORG		0x7c00			; プログラムの開始点のメモリ番地を指定する。疑似命令でCPUでの処理は何もしない。

; 以下は標準的なFAT12フォーマットフロッピーディスクのための記述
		JMP		entry			; 無条件でentryラベルへジャンプ
		DB		0x90			; NOP命令（NO Operation)何もしない
		DB		"kusa-IPL"		; ブートセクタの名前を自由に書いてよい（8バイト）
		DW		512				; 1セクタの大きさ（512にしなければいけない）
		DB		1				; クラスタの大きさ（1セクタにしなければいけない）
		DW		1				; FATがどこから始まるか（普通は1セクタ目からにする）
		DB		2				; FATの個数（2にしなければいけない）
		DW		224				; ルートディレクトリ領域の大きさ（普通は224エントリにする）
		DW		2880			; このドライブの大きさ（2880セクタにしなければいけない）
		DB		0xf0			; メディアのタイプ（0xf0にしなければいけない）
		DW		9				; FAT領域の長さ（9セクタにしなければいけない）
		DW		18				; 1トラックにいくつのセクタがあるか（18にしなければいけない）
		DW		2				; ヘッドの数（2にしなければいけない）
		DD		0				; パーティションを使ってないのでここは必ず0
		DD		2880			; このドライブ大きさをもう一度書く
		DB		0,0,0x29		; よくわからないけどこの値にしておくといいらしい
		DD		0xffffffff		; たぶんボリュームシリアル番号
		DB		"kusa-OS    "	; ディスクの名前（11バイト）
		DB		"FAT12   "		; フォーマットの名前（8バイト）
		RESB	18				; とりあえず18バイトあけておく

; プログラム本体
entry:
		MOV		AX,0			; レジスタ初期化
		MOV		SS,AX			; AXを代入するということは、イコール0を代入する事と同じ。
		MOV		SP,0x7c00		; スタックポインタにORG命令で指定したIPLの開始位置を代入
		MOV		DS,AX
		;MOV		ES,AX		; 突然サイレント削除されている

; ディスクを読み込む
		MOV		AX,0x0820		; 0x8000~0x81ffまでの512バイトは後でブートセクタの内容をいれるので、0x8200を使う。
		MOV		ES,AX			; ESには直接値を入れられないのでAXを介して入れている。ESセグメントでディスクの読み込むセグメントアドレスを指定できる。
		MOV		CH,0			; シリンダ0
		MOV		DH,0			; ヘッド0
		MOV		CL,2			; セクタ2 これでブートセクタの次が読み込める

; 1シリンダの表と裏をそれぞれ18セクタ読んで、それをCYLS分繰り返すためのループ
readloop:
		MOV		SI,0			; 失敗回数を数えるレジスタを初期化

; ディスクをBIOS機能で読み込むための値のセットと機能呼び出し
retry:
		MOV		AH,0x02			; ディスク読み込み: AH=0x02
		MOV		AL,1			; 処理するセクタ: 1セクタ
		MOV		BX,0			; バッファアドレスのオフセットアドレス(細かいメモリ番地)を指定
		MOV		DL,0x00			; ドライブ番号: Aドライブ
		INT		0x13			; ディスク関連のBIOS機能呼び出し
		JNC		next			; JNC命令「Jamp if No Carry」でINT0x13でエラーがなければキャリーフラグが0なので、0だったらnextへジャンプする

;エラーだった時のリトライ処理。5回エラーだったらエラーメッセージに飛ぶ。
		ADD		SI,1			; エラー回数を＋１する
		CMP		SI,5			; CMP命令「CoMPare」比較命令。SI - 5 を行って、結果をステータスフラグにセットする。
		JAE		error			; JAE命令「Jamp if Above or Equal」で直前のCMP命令で、SIが5以上ならジャンプ（>=）
		MOV		AH,0x00			; システムリセットを行うには、AHに0x00をセットする（OS-wikiより）
		MOV		DL,0x00			; ドライブ番号: Aドライブ。
		INT		0x13			; システムリセットのためのBIOS機能呼び出し
		JMP		retry			; 無条件ジャンプ

; 18セクタ読み込む
next:
		MOV		AX,ES			; ESセグメントに読みに行くセグメント(0x0820)が入っていいるので、そこに値を足すため一旦AXに移す
        ADD		AX,0x0020		; 0x0020を足す。実際は × 16されて0x0200(512バイト)が0x8200に足されるので、0x8400になりFDDの1セクタ分メモリ番地が先を示された。
		MOV		ES,AX			; 足した結果をESセグメントに戻す事で、セグメントを進められる。
		ADD		CL,1			; 現在のセクタに+１する
		CMP		CL,18			; セクタが18まで到達するかを CL - 18 を行って確認する。
		JBE		readloop		; JBE命令「Jamp if Below Equal」で直前のCMP命令でCLが18以下ならジャンプ(<=)

; ヘッドの裏側(ヘッド1)を使ってセクタ1~18まで読みにいく。ヘッド0のセクタ18まで読み終わると次は同じシリンダの裏を読みにいく。 
		MOV		CL,1			; セクタ1 セクタ1に戻す。
		ADD		DH,1			; ヘッド1 ヘッド0に1加える
		CMP		DH,2			; CMP命令「CoMPare」比較命令。DH - 2 を行って、結果をステータスフラグにセットする。 
		JB		readloop		; JB命令「Jamp if Below」で直前のCMP命令でDHが2より小さければジャンプ（<)

; CYLS分だけ読みに行く。
		MOV		DH,0			; ヘッドを0に戻して表のヘッドに切り替える。
		ADD		CH,1			; 現在のシリンダ番号に1加える。
		CMP		CH,CYLS			; シリンダがシリンダ定数に達しているか比較
		JB		readloop		; CHがCYLS未満ならreadloopへジャンプ

; 読み込みが終わってkusaOS.sysへジャンプ！
		MOV		[0x0ff0],CH		; セクタの値を0x0ff0へメモして、どこまで読み込んだか記録する
		JMP		0xc200			; kusaOS.sysのあるメモリ番地。ディスクイメージで0x4200以降にkusaOS.sysが入るため、0x8000 + 0x4200 = 0xc200から始まるようにした。

; 以下、エラーメッセージのセクション
error:
		MOV		SI,msg			; msgラベルのメモリ番地をソースインデックスにセット

; メッセージを一文字づつ表示し、文字数分だけループする
putloop:
		MOV		AL,[SI]			; msgの中身の先頭をALに代入
		ADD		SI,1			; ソースインデックスに1を足してmsgの次の文字のメモリ番地を示すようにする
		CMP		AL,0			; msgが最後まで行ったら空になるので、0かどうか比較している
		JE		fin				; 比較の結果0ならばfin：ラベルへジャンプ
		MOV		AH,0x0e			; 比較が0でなければ続く。一文字表示したいのでビデオ割り込みの一文字表示のためにレジスタをセット
		MOV		BX,15			; BHは0でよく、BLはカラーコードを指定。FFFFは白なので15を入れると0x0000FFFFとなる。
		INT		0x10			; ビデオ関連のソフトウェア割り込みを呼び出す
		JMP		putloop			; 一文字づつ表示なので、putloopに戻って繰り返す。（0ならfinに抜ける）

; エラーメッセージを表示し終わったら終わり
fin:
		HLT						; 何かあるまでCPU停止
		JMP		fin				; finラベルへ飛ぶので実質無限ループ

; メッセージ部分
msg:
		DB		0x0a, 0x0a		; 改行を2つ
		DB		"load error"
		DB		0x0a			; 改行
		DB		0

		RESB	0x7dfe-$		; 0x07dfeまでを0x00で埋める命令

		DB		0x55, 0xaa
